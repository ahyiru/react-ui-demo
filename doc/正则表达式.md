# 正则表达式

## 1.正则表达式理论篇

### 构造函数（四种写法）

	var regex = new RegExp('xyz', 'i');  
	var regex = new RegExp(/xyz/i); 
	var regex = /xyz/i; 
	// ES6的写法。ES5在第一个参数是正则时，不允许此时使用第二个参数，会报错。 
	// 返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。
	// 下面代码返回”i”。
	new RegExp(/abc/ig, 'i').flags
	
### 用于模式匹配的String方法

- String.search()

	参数：要搜索的子字符串，或者一个正则表达式。
	返回：第一个与参数匹配的子串的起始位置，如果找不到，返回-1。
	说明：不支持全局搜索，如果参数是字符串，会先通过RegExp构造函数转换成正则表达式。

- String.replace()

	作用：查找并替换字符串。
	第一个参数：字符串或正则表达式，
	第二个参数：要进行替换的字符串，也可以是函数。

- String.match()

	参数：要搜索的子字符串，或者一个正则表达式。
	返回：一个由匹配结果组成的数组。
	
### RegExp的方法

- RegExpObject.exec()
- RegExpObject.test()
- RegExpObject.toString()

### 字符

	| 指示在两个或多个项之间进行选择。类似js中的或，又称分支条件。
	/ 正则表达式模式的开始或结尾。
	\ 反斜杠字符，用来转义。
	- 连字符 当且仅当在字符组[]的内部表示一个范围，比如[A-Z]就是表示范围从A到Z；如果需要在字符组里面表示普通字符-，放在字符组的开头或者尾部即可。
	. 匹配除换行符 \n 之外的任何单个字符。
	\d 等价[0-9]，匹配0到9字符。
	\D 等价[^0-9]，与\d相反。
	\w 与以下任意字符匹配：A-Z、a-z、0-9 和下划线，等价于 [A-Za-z0-9]。
	\W 与\w相反，即 [^A-Za-z0-9]

### 限定符（量词字符）

显示限定符位于大括号 {} 中，并包含指示出现次数上下限的数值；*+? 这三个字符属于单字符限定符：

	{n} 正好匹配 n 次。
	{n,} 至少匹配 n 次。
	{n,m} 匹配至少 n 次，至多 m 次。
	* 等价{0,}
	+ 等价{1,}
	? 等价{0,1}

注意：

显示限定符中，逗号和数字之间不能有空格，否则返回null！

贪婪量词*和+：javascript默认是贪婪匹配，也就是说匹配重复字符是尽可能多地匹配。

惰性（最少重复匹配）量词?：当进行非贪婪匹配，只需要在待匹配的字符后面跟随一个?即可。

	var reg = /a+/;
	var reg2 = /a+?/;
	var str = 'aaab';
	str.match(reg); // ["aaa"]
	str.match(reg2); // ["a"]

### 定位点（锚字符、边界）

- ^ 匹配开始的位置。将 ^ 用作括号[]表达式中的第一个字符，则会对字符集求反。
- $ 匹配结尾的位置。
- \b 与一个字边界匹配，如er\b 与“never”中的“er”匹配，但与“verb”中的“er”不匹配。
- \B 非边界字匹配。

### 非打印字符

	\s 任何空白字符。即[ \f\n\r\t\v]
	\S 任何非空白字符。
	\t Tab 字符(\u0009)。
	\n 换行符(\u000A)
	\v 垂直制表符(\u000B)。
	\f 换页符(\u000C)
	\r 回车符(\u000D)。

注意：\n和\r一起使用，即 /[\r\n]/g来匹配换行，因为unix扩展的系统以\n标志结尾，window以\r\n标志结尾。

### 修饰符

- i 执行不区分大小写的匹配。
- g 执行一个全局匹配，简而言之，即找到所有的匹配，而不是在找到第一个之后就停止。
- m 多行匹配模式，^匹配一行的开头和字符串的开头，$匹配行的结束和字符串的结束。


## 2.正则表达式实践篇

简单的练习：

### 题目

- 与搜索字符串开始处的 3 个数字匹配。
- 与除 a、b 和 c 以外的任何字符匹配。
- '1234567'.match(/\d{1,3}/g)的结果。
- 不以“th”开头的单词匹配。
- 对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字。
- 匹配一个中文字符。

### 答案

	1.与搜索字符串开始处的 3 个数字匹配：/^\d{3}/。
	2.与除 a、b 和 c 以外的任何字符匹配： /[^abc]/。
	3.‘1234567’.match(/\d{1,3}/g)，根据贪婪原则，结果是 ["123", "456", "7"]。
	4.不以“th”开头的单词匹配：/\b(?!th)\w+\b/ 。
	5.对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字： /^(?=.*\d).{4,8}$/ 。首先.{4,8} 表示与包含 4-8 个字符的字符串匹配；然后.*表示单个字符（除换行符 \n 外）零次或多次，且后面跟着一个数字，注意(?=)只匹配一个位置。
	6.匹配一个中文字符：/[\u4e00-\u9fa5]/。
	
当然，可能答案不唯一，不必较真啦~ 主要目的是回忆熟悉一下语法~
如果还不了解正则，可以前往正则表达式理论篇 了解哇~

### 真正的实践来了

要想在复杂性和完整性之间取得平衡，一个重要因素是要了解将要搜索的文本。
好的正则表达式：

只匹配期望的文本，排除不期望的文本；

易于控制和理解；

保证效率。

有时候处理各种极端情况会降低成本/收益的比例。所以某些情况下，不完全依赖正则表达式完成全部工作，比如某些字段用子表达式()括起来，让内存记忆下来，然后再用其他程序来验证。

不过本文还是从学习正则的角度出发，全部依赖正则表达式来写的哇~~

### 匹配美元

正则表达式：`/^\$[0-9]+(\.[0-9][0-9])?$/`。

分为四部分：

- ^\$ 以美元符号开头。
- [0-9]+ 至少包含一个数字。
- (\.[0-9][0-9])? 由一个点和两位数组成，匹配0次或1次，因为可能是整数或者是小数。
- $ 最后的$表示以数字结尾的。

缺点：不能匹配`$1,000`

### 匹配24小时制的时间，比如 09:59

- 小时部分

方法一：分类逻辑为第一个数字(0、1、2)，可以分为三部分：上午 00点到09点（0可选）；白天10到19点；晚上20到23点。

因此有三个多选分支，得到的结果为：

	0?[0-9]|1[0-9]|2[0-3]
还可以优化一下，合并前面的两个多选分支，得到：

	[01]?[0-9]|2[0-3]
方法二：分类逻辑为第二个数字，可以分为两部分：[0-3]和[4-9]。为什么这么分？看看下面这个图就知道了，[0-3]多了一行（以2为第一个数字）：

因此有两个多选分支，结果为：

	[012]?[0-3]|[01]?[4-9]

- 分钟部分

分钟数比较简单，第一个数范围在0-5之间，第二个数在0-9之间，因此得到分钟数为:

	[0-5][0-9]
	
- 最后的结果：

小时部分用(?:)包起来，起到一个分组的作用，且不保存匹配项；

冒号、分钟数拼起来；

最后加上一个分界\b表示单词的开始或结束，得到最终的结果：

	/\b(?:[01]?[0-9]|2[0-3]):[0-5][0-9]\b/
	// 或者
	/\b(?:[012]?[0-3]|[01]?[4-9]):[0-5][0-9]\b/

- 验证：

		var reg = /\b(?:[01]?[0-9]|2[0-3]):[0-5][0-9]\b/;
		'现在是09:49点'.match(reg);	// ["09:49"]
		'现在是009:490点'.match(reg);	 // null
其实这个结果不能说完全正确，首先你要明白这个正则用在什么地方，比如是数据验证或者
复杂的字符串搜寻替换。

情景一：填写表单中的字符串必须为24小时制的时间，那么可能第一个`\b`需要改成`^`，第二个`\b`改成`$`。

情景二：用于复杂的字符串搜寻替换时，可能也会匹配这样子的字符串如’跑步用时19:50’,明显的，’19:50’表示19分50秒，而不是表示24小时制的时间19点50分。

### 匹配IP地址

IP地址的规则：点号分开的四个字段，每个字段在0-255之间。

- 第一步：

如果一个字段是一个数或两个数，肯定是在0-255的范围内的；

如果三位数，那么以0或者1开头的三位数也是合法的，即000-199。

从上面的陈述中我们就可以得到三个多选分支：

	\d|\d\d|[01]\d\d
我们稍微合并一下这三个多选分支，得到：

	[01]?\d\d?
- 第二步：

我们再来看以2开头的三位数：

第二位数小于5的时候，第三位数范围[0-9]都可以；第二位数等于5的时候，第三位数范围[0-5] ，因此得到两个多选分支：

	2[0-4]\d|25[0-5]
第三步：

前两步合并起来，得到一个字段0-255的表示方法：

	[01]?\d\d?|2[0-4]\d|25[0-5]
第四步：

四个字段合并起来，IP地址正则如下：

	/^(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.(?:[01]?\d\d?|2[0-4]\d|25[0-5])$/

点号要转义一下，`^`和`$`需要加上，否则可能匹配52123.3.22.993，因为其中的123.3.22.99是符合的。(?:)起到分组的作用，且不保存匹配项。

一些测试结果：

	var reg = /^(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.(?:[01]?\d\d?|2[0-4]\d|25[0-5])$/;
	'123.11.22.33.44'.match(reg); // null
	'52123.3.22.993'.match(reg);  // null
	'123.11.22.33'.match(reg);  // ["123.11.22.33"]
	'0.0.0.0'.match(reg); 	// ["0.0.0.0"]
虽然0.0.0.0是合法的，但它是非法的IP地址，使用正则的否定顺序环视功能(零宽负向先行断言)，可加上`(?!0+.0+.0+.0+$)` ：

	var reg = /^(?!0+.0+.0+.0+$)(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.(?:[01]?\d\d?|2[0-4]\d|25[0-5])$/;
	'123.11.22.33'.match(reg); // ["123.11.22.33"]
	'0.0.0.0'.match(reg);  // null

### 匹配分隔符之内的文本

#### 常见的匹配要求

匹配`/*和*/`之间的css注释。

匹配引文字符串””，且容许其中包含转义的引号\”。

匹配一个HTML tag，也就是尖括号之内的文本，例如。

#### 匹配思路的步骤

- 匹配起始分隔符。
- 匹配正文（即结束分隔符之前的所有文本）。
- 匹配结束分隔符。

### 容许引文字符串中出现转义引号

### 大概思路

描述：起始分隔符和结束分隔符都是",且正文中容许出现转义之后的引号\"。

简单情况分析：

举例：匹配类似` I "start \"x3\" end" U 文本的 "start \"x3\" end"` 引文字符串，注意\"属于转义引号。

- 起始分隔符和结束分隔符都是"。
- 字符不是引号，肯定是正文。即[^"]表示不是引号的其他任意字符。
- 引号"前面有反斜线\，且被反斜线\转义，则也属于正文。例如start\"引号的前面有一个反斜线，那么这个引号也属于正文。即(?<=\)”表示匹配一个引号，它的前面有一个\，注意正则的反斜线也要用\来转义一下,因为\是特殊字符。

`用非捕获分组(?:)将[^"]|(?<=\\)"括起来，给个量词*，表示匹配正文0次或多次。`

`因此可以写出正则表达式： /"(?:[^"]|(?<=\\)")*"/`

注意：ES7才支持逆序环视(?<=)

#### 验证1：

验证正则：`/"(?:[^"]|(?<=\\)")*"/`

	'I "start \"x3\" end" U'.match(/"(?:[^"]|(?<=\\)")*"/);
	// 结果： [""start ""]
	'I "start \\"x3\\" end" U'.match(/"(?:[^"]|(?<=\\)")*"/);
	// 结果：[""start \"x3\" end""]

为什么第2个才是对的呢？我们看一下返回的input属性就了解了：


#### 验证2：

验证正则：`/"(?:[^"]|(?<=\\)")*"/`

	'I "start \\"x3\\\\" end" U'.match(/"(?:[^"]|(?<=\\)")*"/);
	// 结果与期望不符合：[""start \"x3\\" end""]
	// 期望：[""start\"x3\\"]
	// 注意返回的input属性为："I "start \"x3\\" end" U"

引号”前面有反斜线\，但是这个反斜线不是转义引号的，那么引号就不应该属于正文，而是属于结束分隔符。
什么情况反斜线\不转义引号呢？

这个反斜线\本身就是被转义的情况。

上面的结果按照预期结果应该返回 `[""start\"x3\\"]`，但是现在多了end"。

因此验证这个正则表达式不正确。

也就是说，正文中可出现转义的字符，因此得出正则\\. ，注意第一个\表示转义第二个\,点表示匹配除换行符 \n 之外的任何单个字符）,例如可以匹配\+或者\\。而且转义的字符已经包含了\"的情况，因此正则(?<=\\)"可以不用写了，且替换成\\.。

因此改正后的正则：/"(?:\\.|[^"])*"/

你可能注意到了，我把[^”]和\.的位置调换一下，后面的验证3会讲到为什么要这么做。

#### 验证3：

验证正则：`/"(?:\\.|[^"])*"/ 和 /"(?:[^"]|\\.)*"/`

	'I "start \\"x3\\\\" end" U'.match(/"(?:\\.|[^"])*"/);
	// 结果与期望符合：[""start \"x3\\""]
	// input: "I "start \"x3\\" end" U"
	// [^"]和\\.的位置调换
	'I "start \\"x3\\\\" end" U'.match(/"(?:[^"]|\\.)*"/);
	// 结果与期望不符合：[""start \""]
	// 期望：[""start\"x3\\"]
	// input: "I "start \"x3\\" end" U"

[^"]和\\.的位置调换后，结果与期望不符合。那是因为[^"]匹配start \后，遇到紧接着的"不匹配，交给后面的多选分支\\.，也不匹配，又刚好结束分隔符是",导致匹配成功，结束匹配。

因此两个正则之间 正确的正则是 `/"(?:\\.|[^"])*"/`

#### 验证4：

验证：`/"(?:\\.|[^"])*"/`

	'I "start \\"x3\\" end U'.match(/"(?:\\.|[^"])*"/);
	// 结果与期望不符合：[""start \"x3\""]
	// 注意end后面少了",期望结果是null，不匹配
	// input: "I "start \"x3\" end U"
上面的字符串 "start\"x3\" 其实是没有结束分隔符的，但是还是匹配了。那是因为正则[^"]和\\. 一起作用,导致匹配到了文本U末尾，后续想找结束分隔符的时候，结果却找不到，所以只能回溯文本去找结束分隔符，最后找到了 x3\后面的引号，匹配成功，结束匹配。

回溯会导致不期望的结果，由于是卡在多选分支上出错的，因此猜测多选分支|匹配内容出现重叠。

你想想，如果符合正文的反斜线，不是以[^"]方式匹配,而是以\\.的方式匹配，那就不会把好好的\"拆开来匹配了。

综上所述，一定要让反斜线是以\\.的方式匹配，字符串里的反斜杆不能以[^"]方式匹配。

因此将[^"]改成[^\\"]。这样子就可以确保正确识别正文特殊的\"和结束分隔符"了。

注意：很多字符在[]都会失去本来的意义，但是反斜杠字符 \ 仍为转义字符。若要匹配反斜杠字符，请使用两个反斜杠 \\。

改正的正则：`/"(?:\\.|[^\\"])*"/`

#### 验证5

验证：`/"(?:\\.|[^\\"])*"/`

	'I "start \\"x3\\" end U'.match(/"(?:\\.|[^\\"])*"/);
	// 结果与期望符合：null
	// input: "I "start \"x3\" end" U"
	'I "start \\"x3\\" end" U'.match(/"(?:\\.|[^\\"])*"/);
	// 结果与期望符合：[""start \"x3\" end""]
	// input: "I "start \"x3\" end" U"
为了优化，我们可以把[^\\"]放在前面，因为普通字符的匹配可能性更大。

注意：优化正则提高效率最需要考虑的问题：改动是否会影响匹配。只有在排序与匹配成功无关时才不会影响准确性，才能重新安排多选分支的顺序。

优化后的正则：`/"(?:[^\\"]|\\.)*"/`

### HTML Tag

经历了容许引文字符串中出现转义引号的例子分析，瞬间觉得这个容易了许多。

描述与要求：匹配类似`<input name=123 value=">" >`的HTML标签，起始分隔符是<，结束分隔符是>，且HTML 标签属性值中可以出现>。

起始分隔符和结束分隔符都是明确的，我们来分类一下正文。

- 双引号引用文本
- 单引号引用文本
- 除了>和引号之外的任意字符

可能你会当心单双引号引用文本，会像“容许引文字符串中出现转义引号”那么复杂。幸好是HTML Tag的属性值中不允许出现转义引号，因为平常的转义符号\变成了普通字符。

根据三种情况，分别写出三个正则：

- "[^"]*"
- '[^']*'
- [^'">]

好了，用多选分支连起来"[^"]*"|'[^']*'|[^'">]，再用非捕获分组(?:)将多选分支括起来，如(?:"[^"]*"|'[^']*'|[^'">])，用*表示匹配任意次，最后前后加上开始结束分隔符，搞定：

	/<(?:"[^"]*"|'[^']*'|[^'">])*>/

验证：

	'<input name=123 value=">" >'.match(/<(?:"[^"]*"|'[^']*'|[^'">])*>/)

// 结果： `["<input name=123 value=">" >"]`

#### 体会：

看到没有，几乎每个正则都包含多选分支，只要你懂得将数据分类，离成功就不远了。哈哈哈哈哈。


## 3.

#### 正则表达式——古老而又强大的文本处理工具。仅用一段简短的表达式语句，就能快速地实现一个复杂的业务逻辑。掌握正则表达式，让你的开发效率有一个质的飞跃。

正则表达式经常被用于字段或任意字符串的校验，比如下面这段校验基本日期格式的JavaScript代码：

	var reg = /^(\\d{1,4})(-|\\/)(\\d{1,2})\\2(\\d{1,2})$/; 
	var r = fieldValue.match(reg);             
	if(r==null)alert('Date format error!');

1、校验密码强度

密码的强度必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间

	^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$

2、校验中文

字符串只能是中文

	^[\\u4e00-\\u9fa5]{0,}$

3、由数字，26个英文字母或下划线组成的字符串

	^\\w+$

4、校验E-Mail 地址

	[\\w!#$%&'*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&'*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?

5、校验身份证号码 

15位：

	^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$

18位：

	^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$

6、校验日期 

“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年

	^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$

7、校验金额 

金额校验，精确到2位小数

	^[0-9]+(.[0-9]{2})?$

8、校验手机号 

下面是国内 13、15、18开头的手机号正则表达式

	^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$

9、判断IE的版本

	^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$

10、校验IP-v4地址

	\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b

11、校验IP-v6地址

	(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))

12、检查URL的前缀

	if (!s.match(/^[a-zA-Z]+:\\/\\//)){
   		s = 'http://' + s;}

13、提取URL链接

	^(f|ht){1}(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&=]*)?

14、文件路径及扩展名校验

	^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?"<>|]+\\.txt(l)?$

15、提取Color Hex Codes

	^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$

16、提取网页图片

	\\< *[img][^\\\\>]*[src] *= *[\\"\\']{0,1}([^\\"\\'\\ >]*)

17、提取页面超链接

	(<a\\s*(?!.*\\brel=)[^>]*)(href="https?:\\/\\/)((?!(?:(?:www\\.)?'.implode('|(?:www\\.)?', $follow_list).'))[^"]+)"((?!.*\\brel=)[^>]*)(?:[^>]*)>

18、查找CSS属性

	^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}

19、抽取注释

	<!--(.*?)-->

20、匹配HTML标签

	<\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:".*?"|'.*?'|[\\^'">\\s]+))?)+\\s*|\\s*)\\/?>

一、校验数字的表达式

- 1 数字：`^[0-9]*$`
- 2 n位的数字：`^\d{n}$`
- 3 至少n位的数字：`^\d{n,}$`
- 4 m-n位的数字：`^\d{m,n}$`
- 5 零和非零开头的数字：`^(0|[1-9][0-9]*)$`
- 6 非零开头的最多带两位小数的数字：`^([1-9][0-9]*)+(.[0-9]{1,2})?$`
- 7 带1-2位小数的正数或负数：`^(\-)?\d+(\.\d{1,2})?$`
- 8 正数、负数、和小数：`^(\-|\+)?\d+(\.\d+)?$`
- 9 有两位小数的正实数：`^[0-9]+(.[0-9]{2})?$`
- 10 有1~3位小数的正实数：`^[0-9]+(.[0-9]{1,3})?$`
- 11 非零的正整数：`^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$` 或 `^\+?[1-9][0-9]*$`
- 12 非零的负整数：`^\-[1-9][]0-9"*$` 或 `^-[1-9]\d*$`
- 13 非负整数：`^\d+$` 或 `^[1-9]\d*|0$`
- 14 非正整数：`^-[1-9]\d*|0$` 或 `^((-\d+)|(0+))$`
- 15 非负浮点数：`^\d+(\.\d+)?$` 或 `^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$`
- 16 非正浮点数：`^((-\d+(\.\d+)?)|(0+(\.0+)?))$` 或 `^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$`
- 17 正浮点数：`^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$` 或 `^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$`
- 18 负浮点数：`^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$` 或 `^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$`
- 19 浮点数：`^(-?\d+)(\.\d+)?$` 或 `^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$`

二、校验字符的表达式

- 1 汉字：`^[\u4e00-\u9fa5]{0,}$` 
- 2 英文和数字：`^[A-Za-z0-9]+$` 或 `^[A-Za-z0-9]{4,40}$`
- 3 长度为3-20的所有字符：`^.{3,20}$`
- 4 由26个英文字母组成的字符串：`^[A-Za-z]+$` 
- 5 由26个大写英文字母组成的字符串：`^[A-Z]+$`
- 6 由26个小写英文字母组成的字符串：`^[a-z]+$` 
- 7 由数字和26个英文字母组成的字符串：`^[A-Za-z0-9]+$` 
- 8 由数字、26个英文字母或者下划线组成的字符串：`^\w+$` 或 `^\w{3,20}$`
- 9 中文、英文、数字包括下划线：`^[\u4E00-\u9FA5A-Za-z0-9_]+$`
- 10 中文、英文、数字但不包括下划线等符号：`^[\u4E00-\u9FA5A-Za-z0-9]+$` 或 `^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$`
- 11 可以输入含有^%&',;=?$\"等字符：`[^%&',;=?$\x22]+`
- 12 禁止输入含有~的字符：`[^~\x22]+`

三、特殊需求表达式

- 1 Email地址：

		^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 
- 2 域名：

		[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 
- 3 InternetURL：

		[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$ 
- 4 手机号码：

		^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 
- 5 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：

		^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$  
- 6 国内电话号码(0511-4405222、021-87888822)：

		\d{3}-\d{8}|\d{4}-\d{7} 
- 7 身份证号(15位、18位数字)：

		^\d{15}|\d{18}$ 
- 8 短身份证号码(数字、字母x结尾)：

		^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 
- 9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：

		^[a-zA-Z][a-zA-Z0-9_]{4,15}$
- 10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：

		^[a-zA-Z]\w{5,17}$
- 11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：

		^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$
- 12 日期格式：

		^\d{4}-\d{1,2}-\d{1,2}
- 13 一年的12个月(01～09和1～12)：

		^(0?[1-9]|1[0-2])$
- 14 一个月的31天(01～09和1～31)：

		^((0?[1-9])|((1|2)[0-9])|30|31)$
- 15 钱的输入格式：
	- a.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：

			^[1-9][0-9]*$
	- b.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：

			^(0|[1-9][0-9]*)$
	- c.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：

			^(0|-?[1-9][0-9]*)$
	- d.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：

			^[0-9]+(.[0-9]+)?$
	- e.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：

			^[0-9]+(.[0-9]{2})?$
	- f.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：

			^[0-9]+(.[0-9]{1,2})?$
	- g.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：

			^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$
	- h.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：

			^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$
- 16 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里
- 17 xml文件：

		^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$
- 18 中文字符的正则表达式：

		[\u4e00-\u9fa5]
- 19 双字节字符：

		[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
- 20 空白行的正则表达式：

		\n\s*\r (可以用来删除空白行)
- 21 HTML标记的正则表达式：

		<(\S*?)[^>]*>.*?</\1>|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)
- 22 首尾空白字符的正则表达式：

		^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
- 23 腾讯QQ号：

		[1-9][0-9]{4,} (腾讯QQ号从10000开始)
- 24 中国邮政编码：

		[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)
- 25 IP地址：

		\d+\.\d+\.\d+\.\d+ (提取IP地址时有用) 
- 26 IP地址：

		((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 